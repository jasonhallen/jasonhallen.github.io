<!DOCTYPE html>
<html lang="en"><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Jason Hallen">
<meta name="keywords" content="Jason Hallen, blog, computer music, algorithmic music, electronic music, csound, synthesis, experimental music, Python, graphical user interface, GUI, pygraphqt, pyqt5, frequency spectrum, numpy, scipy, matplotlib, waveform, plotting, graphing">
<meta name="description" content="Here's the way I've found to display Csound amplitude and frequency data quickly and smoothly in Python.">
<!-- <title></title> -->

<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-9FW0V3NTDJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9FW0V3NTDJ');
</script>
<link href="/images/favicon.ico" rel="shortcut icon">
<link href="https://fonts.googleapis.com/css?family=Josefin+Slab" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro" rel="stylesheet">
<link rel="stylesheet" href="/style.css"><title>Exercise: Plotting Csound Data in Python</title></head>

<body>
    <div id="header">
        <span id="jason-hallen">
            <a href="/">Jason Hallen</a>
        </span>
        <div id="nav">
            <ul>
                <li class="active"><a href="/">Blog</a></li>
                <li><a href="/music">Music</a></li>
                <li><a href="/about">About</a></li>
            </ul>
        </div>        
    </div>
    <div id="page-content"><div id="post-section"><h2>Exercise: Plotting Csound Data in Python</h2><span class="muted date">September 21, 2022</span>

<figure><img class="cover-image" src="/images/waveform_detail.png" alt="Audio waveform snapshot"></figure>

<p>Recently in my quest to find a good GUI framework for building Csound instruments I've been exploring Python and <a href="https://riverbankcomputing.com/software/pyqt/intro">PyQt5</a>.  Before this I was exploring Node.js and Electron, but I ran into frustrating problems displaying Csound data in that framework.  So when I switched to PyQt5 the first thing I focused on was displaying data.  I'm happy to report that the results thus far have been great.  Here's the way I've found to display amplitude and frequency data quickly and smoothly.</p>

<h3 id="updating-a-pyqt5-widget">Updating a PyQt5 Widget</h3>
<p>The easiest way to display Csound amplitude in PyQt5 is to use a ready-made widget.  This is just a matter of pulling amplitude data from Csound at regular intervals and updating the widget with the data.  In order to get the look of a VU meter I used PyQt5's <code>QProgressBar</code> widget.  To get the amplitude data out of Csound I experimented with using channels and Open Sound Control (OSC).  I'll only show the channel approach here, but the OSC approach seems better when you need to send lots of data at a fast rate between Csound and the GUI.</p>
<figure><img src="/images/update_progress_bar_widget.gif" alt="Animated image of progress bar updating with amplitude data">
<figcaption>Updating a QProgressBar widget with live amplitude data.</figcaption>
</figure>

<p>For this first example, I'll include the complete Csound code and Python code so you can see how everything works together.  For later examples I'll only include the snippets of code relevant to the examples.</p>
<h4 id="csound-code">Csound Code</h4>
<p>The Csound code below reads the maximum amplitude of the audio signal every k-cycle and sends it out through a channel named "meter".</p>
<pre><code>&lt;CsoundSynthesizer&gt;
&lt;CsOptions&gt;
-d -odac -iadc -+rtaudio=CoreAudio
&lt;/CsOptions&gt;
&lt;CsInstruments&gt;
sr = 44100
nchnls = 1
ksmps = 32
0dbfs = 1

instr 1 ; Microphone input
    asig inch 1
    out asig
    
    ktrig metro 60
    kmeter max_k asig, ktrig, 1
    chnset kmeter, "meter"
endin

&lt;/CsInstruments&gt;
&lt;CsScore&gt;
f 0 z
i 1 0 -1
&lt;/CsScore&gt;
&lt;/CsoundSynthesizer&gt;
</code></pre>
<h4 id="python-code">Python Code</h4>
<p>In Python I explored two options for receiving the channel data from Csound.  The simpler approach is to run a <code>QTimer</code> in the main PyQt5 window that reads the data and updates the <code>QProgressBar</code> widget at regular intervals. The more complicated approach is running a loop in a separate <code>QThread</code> that reads the data and updates the widget using PyQt5's signals and slots to communicate between the threads.</p>
<p>Here's the Python code for the <code>QTimer</code> approach which is run in the <code>QMainWindow</code>. </p>
<pre><code>import sys
import ctcsound
from PyQt5.QtCore import QTimer
from PyQt5.QtWidgets import (
    QApplication,
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QPushButton,
    QProgressBar
)

class MainWindow(QMainWindow):
    '''Main window of program.'''
    def __init__(self):
        super().__init__()
        self.setStyleSheet("background-color: black;")
        
        # Initiate Csound
        self.csound = ctcsound.Csound()
        self.csound.compileCsd("example.csd")
        self.csound.start()
        self.pt = ctcsound.CsoundPerformanceThread(self.csound.csound())

        # Create layout and widgets
        mainLayout = QVBoxLayout()

        self.button = QPushButton("START")
        self.button.setCheckable(True)
        self.button.clicked.connect(self.the_button_was_clicked)

        self.meter = QProgressBar()
        self.meter.setMaximum(100)
        self.meter.setStyleSheet("QProgressBar::chunk "
                          "{"
                          "background-color: white;"
                          "width: 1px;"
                          "}")
        self.meter.setTextVisible(False)
        
        mainLayout.addWidget(self.meter)
        mainLayout.addWidget(self.button)
        centralWidget = QWidget()
        centralWidget.setLayout(mainLayout)
        self.setCentralWidget(centralWidget)

    def the_button_was_clicked(self, status):
        if status:
            self.button.setText("STOP")
            self.pt.play()
            self.timer = QTimer()
            self.timer.setInterval(10)
            self.timer.start()
            self.timer.timeout.connect(self.update_data)
        else:
            self.button.setText("START")
            self.pt.pause()
            self.timer.stop()

    def update_data(self):
        volume = self.csound.controlChannel("meter")[0]
        self.meter.setValue(int(volume * 100))

app = QApplication(sys.argv)
window = MainWindow()
window.show()
sys.exit(app.exec_())
</code></pre>
<p>I was able to get an average of 40 values per second from the Csound channel with this code.  To be honest, I'm not sure why I didn't get more values per second.  This rate is adequate for animation purposes, but I'd like to have higher resolution.  The later examples I'll show also use Csound channels but the data flows faster.  </p>
<h3 id="plotting-a-scrolling-waveform">Plotting a Scrolling Waveform</h3>
<p>Next, I wanted to display the amplitude as a scrolling waveform rather than a VU meter.  I did a quick browse through online tutorials on displaying waveforms in PyQt5, and I saw that the most common way to do this was by plotting the amplitude data on a graph.</p>
<figure><img src="/images/plotting_scrolling_waveform.gif" alt="Animated image of scrolling waveform">
<figcaption>Plotting a scrolling waveform.</figcaption>
</figure>

<p>Brilliant!  I hadn't thought of that before.  When I was using p5.js for my <a href="/blog/project-looper">Looper GUI</a> I drew the waveform as a <code>canvas</code> element.  That was a lot of extra code.  I should have been using a plotting library instead.</p>
<p><a href="https://matplotlib.org/">Matplotlib</a> is a popular way to plot graphs in Python, but <a href="https://www.pyqtgraph.org/">pyqtgraph</a> is better optimized for plotting in PyQt5.  The rule of thumb I read is that matplotlib is better for creating print-quality graphs while pyqtgraph is better for animating graphs in real time.  I used <a href="https://www.pythonguis.com/tutorials/plotting-pyqtgraph/">this tutorial</a> from the very helpful <a href="https://www.pythonguis.com/pyqt5/">Python GUIs</a> website.</p>
<h4 id="csound-code-1">Csound Code</h4>
<p>For this plot, I'll use the same Csound channel data from the first example above.  Here's the new Csound code for sending values through the channel.</p>
<pre><code>ktrig metro 60
kmeter_minimum max_k asig, ktrig, 3
kmeter_maximum max_k asig, ktrig, 2
chnset kmeter_minimum, "meter_minimum"
chnset kmeter_maximum, "meter_maximum"
</code></pre>
<h4 id="python-code-1">Python Code</h4>
<p>And here's the new Python code snippets for plotting the waveform.</p>
<pre><code>[Inside MainWindow class]
def __init__(self, *args, **kwargs):
    # Create PlotWidget and add it to window
    self.plotWidget = pyqtgraph.PlotWidget()
    mainLayout.addWidget(self.plotWidget)

    # Initialize the values of x-axis and y-axis
    axis_length = 128
    self.x = []
    self.y_minimum = []
    self.y_maximum = []
    for i in range(axis_length):
        self.x.append(i)
        self.y_minimum.append(0)
        self.y_maximum.append(0)

    # Plot widget styling
    self.plotWidget.setBackground("black")
    self.plotWidget.showGrid(x=False, y=True)
    self.plotWidget.setYRange(-1.5, 1.5, padding=0)
    self.pen = pg.mkPen(color="white", width=4, capstyle="flatcap")
    self.output_plot = self.plotWidget.plot(self.x, self.y_minimum, pen=self.pen, fillLevel=0, brush="white")
    self.output_plot2 = self.plotWidget.plot(self.x, self.y_maximum, pen=self.pen, fillLevel=0, brush="white")
    xaxis = self.plotWidget.getAxis('bottom')
    xaxis.setStyle(showValues=False)

def update_data(self):
    self.x = self.x[1:]
    self.x.append(self.x[-1] + 1)

    self.y_minimum = self.y_minimum[1:]
    self.y_maximum = self.y_maximum[1:]
    meter_maximum = self.csound.controlChannel("meter_maximum")[0]
    meter_minimum = self.csound.controlChannel("meter_minimum")[0]
    self.y_minimum.append(meter_minimum)
    self.y_maximum.append(meter_maximum)
    
    self.output_plot.setData(self.x, self.y_minimum)
    self.output_plot2.setData(self.x, self.y_maximum)
</code></pre>
<h4 id="how-the-code-works">How the Code Works</h4>
<ul>
<li><p>The amplitude data is stored in the <code>self.x</code>, <code>self.y_minimum</code>, and <code>self.y_maximum</code> lists.  They are first initialized with placeholder values.  We need <code>self.y_minimum</code> and <code>self.y_maximum</code> in order to plot both the top and bottom halves of the waveform.</p>
</li>
<li><p>The <code>self.plotWidget.plot()</code> method adds the x-axis and y-axis data lists to the plot widget.  Importantly, we need to assign the return values of <code>.plot()</code> to the <code>self.output_plot</code> and <code>self.output_plot2</code> variables in order to update the plot data later on.</p>
</li>
<li><p>The plot animation happens in the <code>update_data()</code> function.  The first elements of the x-axis and y-axis lists are removed, and new values are appended to the end.  This is what makes the waveform appear to scroll.  The new values added to the end of the y-axis lists are the minimum and maximum signal data received from Csound.</p>
</li>
<li><p>The <code>.setData()</code> methods update the plots with the new data values, which triggers pyqtgraph to redraw the graphs.</p>
</li>
</ul>
<h3 id="plotting-a-momentary-waveform">Plotting a Momentary Waveform</h3>
<p>Instead of plotting a scrolling waveform that lets you see the waveform over time, what if I wanted to plot a snapshot of the momentary waveform?  This would require a list of continuous samples of the signal over a brief duration.  Using Csound channels won't work in this scenario.</p>
<figure><img src="/images/plotting_momentary_waveform.gif" alt="Animated image of momentary waveform">
<figcaption>Plotting a momentary waveform.</figcaption>
</figure>

<p>First I tried to use the <code>.inputBuffer()</code> method of ctcsound to get this list of continuous samples from Csound, but the input buffer was only 64 samples long.  I intentionally set the buffer to 64 samples in my Csound code to reduce latency for live performance.  Unfortunately, 64 samples was too short to get a good visualization of the waveform.</p>
<p>I needed to figure out a way to provide a larger buffer of continuous samples from Csound.  I decided to maintain my own "virtual buffer" within Csound in the form of a table, and I could then use ctcsound's <code>.table()</code> method to read the table in Python.</p>
<h4 id="csound-code-2">Csound Code</h4>
<p>Here's the code in Csound for maintaining a buffer table that is 2,048 samples long.</p>
<pre><code>gibuffer_size = 2048
gibuffer_offet = gibuffer_size - ksmps
ginput_buffer ftgen 1, 0, -gibuffer_size, 2, 0

instr 1 ; Microphone input
    asig inch 1
    out asig

    ftslice 1, 1, ksmps
    kindex = 0
    while kindex &lt; ksmps do
        tablew asig[kindex], kindex, 1, 0, gibuffer_offet
        kindex += 1
    od
endin
</code></pre>
<h4 id="python-code-2">Python Code</h4>
<p>Here's the Python code that reads data from the table.</p>
<pre><code>[Inside MainWindow class]
def __init__(self, *args, **kwargs):
    # Create PlotWidget and add it to window
    self.plotWidget = pyqtgraph.PlotWidget()
    mainLayout.addWidget(self.plotWidget)

    # Initialize the x-axis
    self.momentary_buffer_length = 512
    self.x_momentary_buffer = []
    for i in range(self.momentary_buffer_length):
        self.x_momentary_buffer.append(i)

    # Plot widget styling
    self.plotWidget.setBackground("black")
    self.plotWidget.showGrid(x=False, y=True)
    self.plotWidget.setYRange(-1.5, 1.5, padding=0)
    self.output_plot = self.plotWidget.plot([], [], pen=self.pen, brush="white")
    xaxis = self.plotWidget.getAxis('bottom')
    xaxis.setStyle(showValues=False)

def update_data(self):
    self.output_plot3.setData(self.x_momentary_buffer, self.csound.table(1)[:self.momentary_buffer_length])
</code></pre>
<h4 id="how-the-code-works-1">How the Code Works</h4>
<ul>
<li><p>In Csound I've created a table called <code>ginput_buffer</code> that holds <code>gibuffer_length</code> samples.  This is my virtual buffer.  For now it's set to 2,048 samples because that works better for plotting momentary waveforms and frequency spectra.</p>
</li>
<li><p>In <code>instr 1</code> the table gets rewritten every k-cycle by the <code>ftslice</code> opcode.  What <code>ftslice</code> does is take a copy of the <code>ginput_buffer</code> table starting at index <code>ksmps</code> and writes it back onto the <code>ginput_buffer</code> table at index 0.  To explain it another way, the table values are shifted to the left by <code>ksmps</code> spaces, which is the number of samples in each k-cycle.</p>
</li>
<li><p>The <code>while kindex &lt; ksmps do</code> loop then writes the audio array of the current k-cycle, which is <code>ksmps</code> samples long, to the end of the <code>ginput_buffer</code> table.  The <code>gibuffer_offset</code> variable tells the <code>tablew</code> opcode the starting index to write these values to in the table.</p>
</li>
<li><p>In Python <code>self.momentary_buffer_length</code> sets the number of samples to be displayed in the momentary waveform.  It could be as long as <code>gibuffer_length</code>, but 2,048 is actually pretty large.  I've found that "zooming in" to 512 samples works well for teh momentary waveform.  You might wonder why I don't just set <code>gibuffer_length</code> in Csound to 512 samples.  That's because I need the length to be 2,048 to better plot the frequency spectrum as described below.</p>
</li>
<li><p>In <code>update_data()</code> I update the plot by reading in the table data from Csound.  Notice that I slice the data list to a length of <code>self.momentary_buffer_length</code>.</p>
</li>
</ul>
<h3 id="plotting-a-frequency-spectrum">Plotting a Frequency Spectrum</h3>
<p>Finally, I wanted to plot the frequency spectrum of the audio signal.  To do this I needed to calculate the <a href="https://en.wikipedia.org/wiki/Fast_Fourier_transform"><strong>fast Fourier transform (FFT)</strong></a> on a list of continuous audio samples.  <a href="https://scipy.org/">SciPy</a> is considered the best Python library for calculating FFTs.</p>
<figure><img src="/images/plotting_frequency_spectrum.gif" alt="Animated image of frequency spectrum">
<figcaption>Plotting a frequency spectrum.</figcaption>
</figure>

<h4 id="csound-code-3">Csound Code</h4>
<p>The Csound code is exactly the same as the previous example, so there's no need to repeat it here.  The key is that the <code>ginput_buffer</code> table contains the most recent 2,048 samples of audio data which gets updated every k-cycle.</p>
<h4 id="python-code-3">Python Code</h4>
<pre><code>import numpy as np
from scipy.fft import rfft, rfftfreq

[Inside MainWindow class]
def __init__(self, *args, **kwargs):
    # Create PlotWidget and add it to window
    self.plotWidget = pyqtgraph.PlotWidget()
    mainLayout.addWidget(self.plotWidget)

    # Plot widget styling
    self.plotWidget.setBackground("black")
    self.plotWidget.showGrid(x=False, y=True)
    self.plotWidget.setYRange(-0.1, 3, padding=0)

    # Set up x-axis with logarithmic units
    self.plotWidget.setLogMode(x=True, y=False)
    xaxis_ticks = [(np.log10(20),"20"),(np.log10(100),"100"),(np.log10(200),"200"),
    (np.log10(400),"400"),(np.log10(600),"600"),(np.log10(1000),"1k"),(np.log10(2000),
    "2k"),(np.log10(3000),"3k"),(np.log10(10000),"10k")]
    xaxis = self.plotWidget.getAxis('bottom')
    xaxis.setTicks([xaxis_ticks])

    self.output_plot = self.plotWidget.plot([], [], pen=self.pen)

def update_data(self):
    fft_spectrum = rfft(self.csound.table(1), norm="ortho")
    freq = rfftfreq(2048, 1./44100)
    self.output_plot.setData(freq, np.abs(fft_spectrum))
</code></pre>
<h4 id="how-the-code-works-2">How the Code Works</h4>
<ul>
<li><p><code>self.plotWidget.setLogMode(x=True, y=False)</code> sets the x-axis to a logarithmic scale.  This plots the frequency spectrum along the x-axis in a more useful way.  <code>xaxis_ticks</code> is a list of logarithmic values which defines the tick marks along the x-axis.  I use <a href="https://numpy.org/">NumPy</a> to define the logarithmic values.  I learned these techniques from <a href="https://www.youtube.com/watch?v=RHmTgapLu4s">this YouTube video</a> by Mark Jay.</p>
</li>
<li><p><code>rfft()</code> is SciPy's "real FFT" function, which only includes the real numbers in the calculation.  This is more efficient, and it meets the needs of the audio analysis well.  <code>rfft()</code> reads the data from the <code>ginput_buffer</code> table in Csound, performs the RFFT calculation, and outputs <code>fft_spectrum</code> which is a list of power values corresponding to frequency bands across the audio spectrum. </p>
</li>
<li><p><code>rfftfreq()</code> generates a list of frequency values that corresponds to the power values contained in <code>fft_spectrum</code>.  These frequency values are plotted along the x-axis, and the power values are plotted along the y-axis.</p>
</li>
</ul>
<h3 id="next-steps">Next Steps</h3>
<p>So far my exploration of PyQt5 has been successful.  I've been able to create quality data animations that easily render at 60 frames per second, and achieving this was much more straightforward in PyQt5 than in Node.js and Electron.</p>
<p>Here are some areas I'll focus on next.</p>
<ul>
<li><p>I need to figure out how to properly normalize the FFT data in the frequency spectrum plot.  The numbers spike off the charts.  There are tutorials for normalizing FFT data online, but for some reason I can't get it to work.  I must be doing something wrong or misunderstanding something.</p>
</li>
<li><p>The graphic design of GUIs is important to me for both aesthetic and functional reasons, so I'd like to use the PyQt5 style sheet to better manage the design of the window and widgets.</p>
</li>
<li><p>I built this with PyQt5, but PyQt6 is actually the latest version to be released.  At some point I'll switch this over, which might not require any changes to my actual code.</p>
</li>
<li><p>The real test of the PyQt5 framework will come when I create a more complicated application.  That will reveal any performance issues that will force me to compromise or get creative with the animation algorithms.</p>
</li>
</ul>
<p>Now the fun can really begin as I dream up new instruments and generative systems with Python and Csound.</p>
<div id="prev-next-container"><span class="older-button"><a href="/blog/update-csound-nodejs-electron" class="readmore">Older</a></span></div></div><div id="comments-section"><div id="comment-form"><form class="js-form" method="post" action="https://jasonhallen-staticman.herokuapp.com/v3/entry/github/jasonhallen/jasonhallen.github.io/main/comments">
    
    <!-- <input type="hidden" name="options[origin]" value="{{ page.url | absolute_url }}"> -->
    <input type="hidden" name="options[parent]" value="https://jasonhallen.com/blog/exercise-plotting-csound-data-in-python.html">
    <!-- <input name="options[redirect]" type="hidden" value="https://jasonhallen.com/thanks"> -->
    <input type="hidden" id="comment-replying-to-uid" name="fields[replying_to_uid]" value="">
    <input type="hidden" name="options[slug]" value="exercise-plotting-csound-data-in-python">
    
    <!-- reCaptcha -->
    <input type="hidden" name="options[reCaptcha][siteKey]" value="6LcsNJIhAAAAAIF7ND_Y8QPGuocbqYoe3LPpNWPI">
    <input type="hidden" name="options[reCaptcha][secret]" value="J/1tx/gxjjcF4Qw17kZ0QUhUK9xnotL31qIetlT0EGmt7rZEyYfRDfKKHit/hxajHF4EV898b9pWqF0nbhZVa+j+AmxyMrcJTvP7lD0Fvfdk6fK/W/6OMe1q3dOROo/HIF5lLmDcdFMKc9L1Y3T0wDNuStn2lvL3v2ECnajXG5/CSurNFRnFq1k1iwGvHn5XLeypNgz08MKk+5E5f55DyEeRwxtLu2wAaiyIBISpboEas5v9OZpPoclYnYWneAiX0CeccxGSL3EyxJ3CCD9GSJsFrrOYAPRRujw4hXmRzAzzJunSLd1V4icFPaqlsqWYAGYMehQeeHlV77MAcg7gxeSJv9GVyrfbtg82yhsASgtkGhtUFEmN7AenM1XZs4TDqUUxP01o9Gj/oYmfGQUdr734IVewVQkcm65zF092ZSeeTefX/5s8cZedPiFK6bvLylbFxu/s4kLG482H/ZU64QdSIyrDuSzOISbZo+0Yd9OlElvkgeZML6+pyjd8SrNjxfCSA1bgOhb+3aGfXKVw+JxinWCizR2JB6Q/FOZzEa4I0aefzOeGwNK8XGC/vHzmt/58KFeEDNTpse77cHywvoT74XVIciJcPUvTrq6rAw5tkaekmuDX03Trefxo+pAMBXqj8wy06mgYsg721XNd8IpE+Qk7wPs/Dv8BfEhH6sc=">
    
    <h2 id="comment-form-header">Leave a Comment</h2>

    <div class="textfield">
        <p>Your email address will not be published. Required fields are marked *</p>
        <label for="comment-form-message"><strong>Comment *</strong></label>
        <textarea class="textfield__input" name="fields[message]" type="text" id="comment-form-message" placeholder="[You can use Markdown.]" required="" rows="6"></textarea>
    </div>

    <div class="textfield">
        <label for="comment-form-name"><strong>Name *</strong></label>
        <br>
        <input class="textfield__input" name="fields[name]" type="text" id="comment-form-name" required="">
    </div>
    
    <div class="textfield">
        <label for="comment-form-email"><strong>Email</strong></label>
        <br>
        <input class="textfield__input" name="fields[email]" type="email" id="comment-form-email">
    </div>
    
    <div class="textfield hp">
    <label for="hp">
        <input class="textfield__input" name=" hp" id="hp" type="text" placeholder="Leave blank">
    </label>
    </div>

    <div id="reCaptcha" class="g-recaptcha" data-sitekey="6LcsNJIhAAAAAIF7ND_Y8QPGuocbqYoe3LPpNWPI"></div>

    <div id="submit-cancel-buttons">
        <button class="readmore" id="comment-form-submit">
        Submit
        </button>

        <button type="button" class="readmore" id="cancel-comment-reply-link" style="display: none">
        Cancel
        </button>
        <!-- <p id="recaptcha-fine-print"><small>This site is protected by reCAPTCHA and the Google <a href="https://policies.google.com/privacy">Privacy Policy</a> and <a href="https://policies.google.com/terms">Terms of Service</a> apply.</small></p> -->
    </div>

</form>

<div id="modal-wrapper" style="display: none;">
    <article class="modal">
        <img class="modal-image" src="">
            <div id="modal-text-wrapper">
            <h3 class="modal-title js-modal-title"></h3>
            <div class="mdl-card__supporting-text js-modal-text"></div>
            <div class="mdl-card__actions mdl-card--border">
                <button class="button readmore mdl-button--colored mdl-js-button mdl-js-ripple-effect js-close-modal">
                    Close
                </button>
            </div>
        </div>
    </article>
</div>

<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
    <symbol id="icon-loading" viewBox="149.8 37.8 499.818 525"><path d="M557.8 187.8c13.8 0 24.601-10.8 24.601-24.6S571.6 138.6 557.8 138.6s-24.6 10.8-24.6 24.6c0 13.2 10.8 24.6 24.6 24.6zm61.2 90.6c-16.8 0-30.6 13.8-30.6 30.6s13.8 30.6 30.6 30.6 30.6-13.8 30.6-30.6c.6-16.8-13.2-30.6-30.6-30.6zm-61.2 145.2c-20.399 0-36.6 16.2-36.6 36.601 0 20.399 16.2 36.6 36.6 36.6 20.4 0 36.601-16.2 36.601-36.6C595 439.8 578.2 423.6 557.8 423.6zM409 476.4c-24 0-43.2 19.199-43.2 43.199s19.2 43.2 43.2 43.2 43.2-19.2 43.2-43.2S433 476.4 409 476.4zM260.8 411c-27 0-49.2 22.2-49.2 49.2s22.2 49.2 49.2 49.2 49.2-22.2 49.2-49.2-22.2-49.2-49.2-49.2zm-10.2-102c0-27.6-22.8-50.4-50.4-50.4-27.6 0-50.4 22.8-50.4 50.4 0 27.6 22.8 50.4 50.4 50.4 27.6 0 50.4-22.2 50.4-50.4zm10.2-199.8c-30 0-54 24-54 54s24 54 54 54 54-24 54-54-24.6-54-54-54zM409 37.8c-35.4 0-63.6 28.8-63.6 63.6S374.2 165 409 165s63.6-28.8 63.6-63.6-28.2-63.6-63.6-63.6z"></path>
    </symbol>
</svg></div></div></div>
    <script src="/comments.js"></script>


<script src="https://www.google.com/recaptcha/api.js?render=reCAPTCHA_site_key"></script>
</body><!-- <script src="https://www.google.com/recaptcha/api.js" async defer></script> --></html>